/*******************************************************************************
    DO NOT EDIT
    This file was generated by module generate
*******************************************************************************/
package kotlinx.html.js

import kotlinx.html.*
import kotlinx.html.attributes.*

import kotlin.Deprecated
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlinx.html.A
import kotlinx.html.ABBR
import kotlinx.html.ADDRESS
import kotlinx.html.AREA
import kotlinx.html.ARTICLE
import kotlinx.html.ASIDE
import kotlinx.html.AUDIO
import kotlinx.html.AreaShape
import kotlinx.html.B
import kotlinx.html.BASE
import kotlinx.html.BDI
import kotlinx.html.BDO
import kotlinx.html.BLOCKQUOTE
import kotlinx.html.BODY
import kotlinx.html.BR
import kotlinx.html.BUTTON
import kotlinx.html.ButtonFormEncType
import kotlinx.html.ButtonFormMethod
import kotlinx.html.ButtonType
import kotlinx.html.CANVAS
import kotlinx.html.CAPTION
import kotlinx.html.CITE
import kotlinx.html.CODE
import kotlinx.html.COL
import kotlinx.html.COLGROUP
import kotlinx.html.COMMAND
import kotlinx.html.CommandType
import kotlinx.html.DATALIST
import kotlinx.html.DD
import kotlinx.html.DEL
import kotlinx.html.DETAILS
import kotlinx.html.DFN
import kotlinx.html.DIALOG
import kotlinx.html.DIV
import kotlinx.html.DL
import kotlinx.html.DT
import kotlinx.html.EM
import kotlinx.html.EMBED
import kotlinx.html.FIELDSET
import kotlinx.html.FIGCAPTION
import kotlinx.html.FIGURE
import kotlinx.html.FOOTER
import kotlinx.html.FORM
import kotlinx.html.FormEncType
import kotlinx.html.FormMethod
import kotlinx.html.H1
import kotlinx.html.H2
import kotlinx.html.H3
import kotlinx.html.H4
import kotlinx.html.H5
import kotlinx.html.H6
import kotlinx.html.HEAD
import kotlinx.html.HEADER
import kotlinx.html.HGROUP
import kotlinx.html.HR
import kotlinx.html.HTML
import kotlinx.html.HtmlTagMarker
import kotlinx.html.I
import kotlinx.html.IFRAME
import kotlinx.html.IMG
import kotlinx.html.INPUT
import kotlinx.html.INS
import kotlinx.html.IframeSandbox
import kotlinx.html.ImgLoading
import kotlinx.html.InputFormEncType
import kotlinx.html.InputFormMethod
import kotlinx.html.InputType
import kotlinx.html.KBD
import kotlinx.html.KEYGEN
import kotlinx.html.KeyGenKeyType
import kotlinx.html.LABEL
import kotlinx.html.LEGEND
import kotlinx.html.LI
import kotlinx.html.LINK
import kotlinx.html.MAIN
import kotlinx.html.MAP
import kotlinx.html.MARK
import kotlinx.html.MATH
import kotlinx.html.MATHML
import kotlinx.html.META
import kotlinx.html.METER
import kotlinx.html.NAV
import kotlinx.html.NOSCRIPT
import kotlinx.html.OBJECT
import kotlinx.html.OL
import kotlinx.html.OPTGROUP
import kotlinx.html.OPTION
import kotlinx.html.OUTPUT
import kotlinx.html.P
import kotlinx.html.PARAM
import kotlinx.html.PICTURE
import kotlinx.html.PRE
import kotlinx.html.PROGRESS
import kotlinx.html.Q
import kotlinx.html.RP
import kotlinx.html.RT
import kotlinx.html.RUBY
import kotlinx.html.S
import kotlinx.html.SAMP
import kotlinx.html.SCRIPT
import kotlinx.html.SECTION
import kotlinx.html.SELECT
import kotlinx.html.SMALL
import kotlinx.html.SOURCE
import kotlinx.html.SPAN
import kotlinx.html.STRONG
import kotlinx.html.STYLE
import kotlinx.html.SUB
import kotlinx.html.SUMMARY
import kotlinx.html.SUP
import kotlinx.html.SVG
import kotlinx.html.ScriptCrossorigin
import kotlinx.html.TABLE
import kotlinx.html.TBODY
import kotlinx.html.TD
import kotlinx.html.TEXTAREA
import kotlinx.html.TFOOT
import kotlinx.html.TH
import kotlinx.html.THEAD
import kotlinx.html.TIME
import kotlinx.html.TITLE
import kotlinx.html.TR
import kotlinx.html.TagConsumer
import kotlinx.html.TextAreaWrap
import kotlinx.html.ThScope
import kotlinx.html.U
import kotlinx.html.UL
import kotlinx.html.VAR
import kotlinx.html.VIDEO
import org.w3c.dom.Element
import org.w3c.dom.HTMLAnchorElement
import org.w3c.dom.HTMLAreaElement
import org.w3c.dom.HTMLAudioElement
import org.w3c.dom.HTMLBRElement
import org.w3c.dom.HTMLBaseElement
import org.w3c.dom.HTMLBodyElement
import org.w3c.dom.HTMLButtonElement
import org.w3c.dom.HTMLCanvasElement
import org.w3c.dom.HTMLDataListElement
import org.w3c.dom.HTMLDetailsElement
import org.w3c.dom.HTMLDialogElement
import org.w3c.dom.HTMLDivElement
import org.w3c.dom.HTMLEmbedElement
import org.w3c.dom.HTMLFieldSetElement
import org.w3c.dom.HTMLFormElement
import org.w3c.dom.HTMLHRElement
import org.w3c.dom.HTMLHeadElement
import org.w3c.dom.HTMLHeadingElement
import org.w3c.dom.HTMLHtmlElement
import org.w3c.dom.HTMLImageElement
import org.w3c.dom.HTMLInputElement
import org.w3c.dom.HTMLLIElement
import org.w3c.dom.HTMLLabelElement
import org.w3c.dom.HTMLLegendElement
import org.w3c.dom.HTMLLinkElement
import org.w3c.dom.HTMLMapElement
import org.w3c.dom.HTMLMetaElement
import org.w3c.dom.HTMLMeterElement
import org.w3c.dom.HTMLOptGroupElement
import org.w3c.dom.HTMLOptionElement
import org.w3c.dom.HTMLOutputElement
import org.w3c.dom.HTMLParagraphElement
import org.w3c.dom.HTMLParamElement
import org.w3c.dom.HTMLPictureElement
import org.w3c.dom.HTMLPreElement
import org.w3c.dom.HTMLProgressElement
import org.w3c.dom.HTMLScriptElement
import org.w3c.dom.HTMLSelectElement
import org.w3c.dom.HTMLSourceElement
import org.w3c.dom.HTMLSpanElement
import org.w3c.dom.HTMLStyleElement
import org.w3c.dom.HTMLTableCellElement
import org.w3c.dom.HTMLTableColElement
import org.w3c.dom.HTMLTableElement
import org.w3c.dom.HTMLTableRowElement
import org.w3c.dom.HTMLTableSectionElement
import org.w3c.dom.HTMLTextAreaElement
import org.w3c.dom.HTMLTimeElement
import org.w3c.dom.HTMLTitleElement
import org.w3c.dom.HTMLVideoElement

/**
 * Anchor
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.a(
  href: String? = null,
  target: String? = null,
  classes: String? = null,
  crossinline block: A.() -> Unit = {},
): HTMLAnchorElement = A(attributesMapOf("href", href,"target", target,"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLAnchorElement

/**
 * Abbreviated form (e.g., WWW, HTTP,etc.)
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.abbr(classes: String? = null, crossinline
    block: ABBR.() -> Unit = {}): Element = ABBR(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Information on author
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.address(classes: String? = null, crossinline
    block: ADDRESS.() -> Unit = {}): Element = ADDRESS(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Client-side image map area
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.area(
  shape: AreaShape? = null,
  alt: String? = null,
  classes: String? = null,
  crossinline block: AREA.() -> Unit = {},
): HTMLAreaElement = AREA(attributesMapOf("Shape", shape?.enumEncode(),"alt", alt,"class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLAreaElement

/**
 * Self-contained syndicatable or reusable composition
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.article(classes: String? = null, crossinline
    block: ARTICLE.() -> Unit = {}): Element = ARTICLE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Sidebar for tangentially related content
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.aside(classes: String? = null, crossinline
    block: ASIDE.() -> Unit = {}): Element = ASIDE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Audio player
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.audio(classes: String? = null, crossinline
    block: AUDIO.() -> Unit = {}): HTMLAudioElement = AUDIO(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLAudioElement

/**
 * Bold text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.b(classes: String? = null, crossinline block: B.() -> Unit =
    {}): Element = B(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Document base URI
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.base(classes: String? = null, crossinline
    block: BASE.() -> Unit = {}): HTMLBaseElement = BASE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLBaseElement

/**
 * Text directionality isolation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.bdi(classes: String? = null, crossinline
    block: BDI.() -> Unit = {}): Element = BDI(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * I18N BiDi over-ride
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.bdo(classes: String? = null, crossinline
    block: BDO.() -> Unit = {}): Element = BDO(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Long quotation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.blockQuote(classes: String? = null, crossinline
    block: BLOCKQUOTE.() -> Unit = {}): Element = BLOCKQUOTE(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block) 

/**
 * Document body
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.body(classes: String? = null, crossinline
    block: BODY.() -> Unit = {}): HTMLBodyElement = BODY(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLBodyElement

/**
 * Forced line break
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.br(classes: String? = null, crossinline block: BR.() -> Unit
    = {}): HTMLBRElement = BR(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLBRElement

/**
 * Push button
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.button(
  formEncType: ButtonFormEncType? = null,
  formMethod: ButtonFormMethod? = null,
  name: String? = null,
  type: ButtonType? = null,
  classes: String? = null,
  crossinline block: BUTTON.() -> Unit = {},
): HTMLButtonElement = BUTTON(attributesMapOf("formenctype", formEncType?.enumEncode(),"formmethod",
    formMethod?.enumEncode(),"name", name,"type", type?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLButtonElement

/**
 * Scriptable bitmap canvas
 */
@HtmlTagMarker
public fun TagConsumer<Element>.canvas(classes: String? = null, content: String = ""):
    HTMLCanvasElement = CANVAS(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})  as HTMLCanvasElement

/**
 * Scriptable bitmap canvas
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.canvas(classes: String? = null, crossinline
    block: CANVAS.() -> Unit = {}): HTMLCanvasElement = CANVAS(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLCanvasElement

/**
 * Table caption
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.caption(classes: String? = null, crossinline
    block: CAPTION.() -> Unit = {}): Element = CAPTION(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Citation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.cite(classes: String? = null, crossinline
    block: CITE.() -> Unit = {}): Element = CITE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Computer code fragment
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.code(classes: String? = null, crossinline
    block: CODE.() -> Unit = {}): Element = CODE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Table column
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.col(classes: String? = null, crossinline
    block: COL.() -> Unit = {}): HTMLTableColElement = COL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTableColElement

/**
 * Table column group
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.colGroup(classes: String? = null, crossinline
    block: COLGROUP.() -> Unit = {}): HTMLTableColElement = COLGROUP(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLTableColElement

@HtmlTagMarker
public inline fun TagConsumer<Element>.command(
  type: CommandType? = null,
  classes: String? = null,
  crossinline block: COMMAND.() -> Unit = {},
): Element = COMMAND(attributesMapOf("type", type?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Container for options for 
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dataList(classes: String? = null, crossinline
    block: DATALIST.() -> Unit = {}): HTMLDataListElement = DATALIST(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLDataListElement

/**
 * Definition description
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dd(classes: String? = null, crossinline block: DD.() -> Unit
    = {}): Element = DD(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Deleted text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.del(classes: String? = null, crossinline
    block: DEL.() -> Unit = {}): Element = DEL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Disclosure control for hiding details
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.details(classes: String? = null, crossinline
    block: DETAILS.() -> Unit = {}): HTMLDetailsElement = DETAILS(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLDetailsElement

/**
 * Instance definition
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dfn(classes: String? = null, crossinline
    block: DFN.() -> Unit = {}): Element = DFN(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Dialog box or window
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dialog(classes: String? = null, crossinline
    block: DIALOG.() -> Unit = {}): HTMLDialogElement = DIALOG(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLDialogElement

/**
 * Generic language/style container
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.div(classes: String? = null, crossinline
    block: DIV.() -> Unit = {}): HTMLDivElement = DIV(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLDivElement

/**
 * Definition list
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dl(classes: String? = null, crossinline block: DL.() -> Unit
    = {}): Element = DL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Definition term
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.dt(classes: String? = null, crossinline block: DT.() -> Unit
    = {}): Element = DT(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Emphasis
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.em(classes: String? = null, crossinline block: EM.() -> Unit
    = {}): Element = EM(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Plugin
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.embed(classes: String? = null, crossinline
    block: EMBED.() -> Unit = {}): HTMLEmbedElement = EMBED(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLEmbedElement

/**
 * Form control group
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.fieldSet(classes: String? = null, crossinline
    block: FIELDSET.() -> Unit = {}): HTMLFieldSetElement = FIELDSET(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLFieldSetElement

/**
 * Caption for 
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.figcaption(classes: String? = null, crossinline
    block: FIGCAPTION.() -> Unit = {}): Element = FIGCAPTION(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block) 

/**
 * Figure with optional caption
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.figure(classes: String? = null, crossinline
    block: FIGURE.() -> Unit = {}): Element = FIGURE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Footer for a page or section
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.footer(classes: String? = null, crossinline
    block: FOOTER.() -> Unit = {}): Element = FOOTER(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Interactive form
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.form(
  action: String? = null,
  encType: FormEncType? = null,
  method: FormMethod? = null,
  classes: String? = null,
  crossinline block: FORM.() -> Unit = {},
): HTMLFormElement = FORM(attributesMapOf("action", action,"enctype",
    encType?.enumEncode(),"method", method?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLFormElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h1(classes: String? = null, crossinline block: H1.() -> Unit
    = {}): HTMLHeadingElement = H1(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h2(classes: String? = null, crossinline block: H2.() -> Unit
    = {}): HTMLHeadingElement = H2(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h3(classes: String? = null, crossinline block: H3.() -> Unit
    = {}): HTMLHeadingElement = H3(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h4(classes: String? = null, crossinline block: H4.() -> Unit
    = {}): HTMLHeadingElement = H4(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h5(classes: String? = null, crossinline block: H5.() -> Unit
    = {}): HTMLHeadingElement = H5(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Heading
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.h6(classes: String? = null, crossinline block: H6.() -> Unit
    = {}): HTMLHeadingElement = H6(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHeadingElement

/**
 * Document head
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun TagConsumer<Element>.head(content: String = ""): HTMLHeadElement = HEAD(emptyMap, this)
    .visitAndFinalize(this, {+content})  as HTMLHeadElement

/**
 * Document head
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.head(crossinline block: HEAD.() -> Unit = {}):
    HTMLHeadElement = HEAD(emptyMap, this)
    .visitAndFinalize(this, block)  as HTMLHeadElement

/**
 * Introductory or navigational aids for a page or section
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.`header`(classes: String? = null, crossinline
    block: HEADER.() -> Unit = {}): Element = HEADER(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

@HtmlTagMarker
public inline fun TagConsumer<Element>.hGroup(classes: String? = null, crossinline
    block: HGROUP.() -> Unit = {}): Element = HGROUP(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Horizontal rule
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.hr(classes: String? = null, crossinline block: HR.() -> Unit
    = {}): HTMLHRElement = HR(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLHRElement

/**
 * Document root element
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun TagConsumer<Element>.html(content: String = "", namespace: String? = null):
    HTMLHtmlElement = HTML(emptyMap, this, namespace)
    .visitAndFinalize(this, {+content})  as HTMLHtmlElement

/**
 * Document root element
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.html(namespace: String? = null, crossinline
    block: HTML.() -> Unit = {}): HTMLHtmlElement = HTML(emptyMap, this, namespace)
    .visitAndFinalize(this, block)  as HTMLHtmlElement

/**
 * Italic text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.i(classes: String? = null, crossinline block: I.() -> Unit =
    {}): Element = I(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Inline subwindow
 */
@HtmlTagMarker
public fun TagConsumer<Element>.iframe(
  sandbox: IframeSandbox? = null,
  classes: String? = null,
  content: String = "",
): Element = IFRAME(attributesMapOf("sandbox", sandbox?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, {+content}) 

/**
 * Inline subwindow
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.iframe(
  sandbox: IframeSandbox? = null,
  classes: String? = null,
  crossinline block: IFRAME.() -> Unit = {},
): Element = IFRAME(attributesMapOf("sandbox", sandbox?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Embedded image
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.img(
  alt: String? = null,
  src: String? = null,
  loading: ImgLoading? = null,
  classes: String? = null,
  crossinline block: IMG.() -> Unit = {},
): HTMLImageElement = IMG(attributesMapOf("alt", alt,"src", src,"loading",
    loading?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLImageElement

/**
 * Form control
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.input(
  type: InputType? = null,
  formEncType: InputFormEncType? = null,
  formMethod: InputFormMethod? = null,
  name: String? = null,
  classes: String? = null,
  crossinline block: INPUT.() -> Unit = {},
): HTMLInputElement = INPUT(attributesMapOf("type", type?.enumEncode(),"formenctype",
    formEncType?.enumEncode(),"formmethod", formMethod?.enumEncode(),"name", name,"class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLInputElement

/**
 * Inserted text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.ins(classes: String? = null, crossinline
    block: INS.() -> Unit = {}): Element = INS(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Text to be entered by the user
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.kbd(classes: String? = null, crossinline
    block: KBD.() -> Unit = {}): Element = KBD(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Cryptographic key-pair generator form control
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.keyGen(
  keyType: KeyGenKeyType? = null,
  classes: String? = null,
  crossinline block: KEYGEN.() -> Unit = {},
): Element = KEYGEN(attributesMapOf("keytype", keyType?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Form field label text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.label(classes: String? = null, crossinline
    block: LABEL.() -> Unit = {}): HTMLLabelElement = LABEL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLLabelElement

/**
 * Fieldset legend
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.legend(classes: String? = null, crossinline
    block: LEGEND.() -> Unit = {}): HTMLLegendElement = LEGEND(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLLegendElement

/**
 * List item
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.li(classes: String? = null, crossinline block: LI.() -> Unit
    = {}): HTMLLIElement = LI(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLLIElement

/**
 * A media-independent link
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.link(
  href: String? = null,
  rel: String? = null,
  type: String? = null,
  crossinline block: LINK.() -> Unit = {},
): HTMLLinkElement = LINK(attributesMapOf("href", href,"rel", rel,"type", type), this)
    .visitAndFinalize(this, block)  as HTMLLinkElement

/**
 * Container for the dominant contents of another element
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.main(classes: String? = null, crossinline
    block: MAIN.() -> Unit = {}): Element = MAIN(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Client-side image map
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.map(
  name: String? = null,
  classes: String? = null,
  crossinline block: MAP.() -> Unit = {},
): HTMLMapElement = MAP(attributesMapOf("name", name,"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLMapElement

/**
 * Highlight
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.mark(classes: String? = null, crossinline
    block: MARK.() -> Unit = {}): Element = MARK(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

@HtmlTagMarker
public inline fun TagConsumer<Element>.math(classes: String? = null, crossinline
    block: MATH.() -> Unit = {}): Element = MATH(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

@HtmlTagMarker
public fun TagConsumer<Element>.mathml(classes: String? = null, content: String = ""): Element =
    MATHML(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content}) 

@HtmlTagMarker
public inline fun TagConsumer<Element>.mathml(classes: String? = null, crossinline
    block: MATHML.() -> Unit = {}): Element = MATHML(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Generic metainformation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.meta(
  name: String? = null,
  content: String? = null,
  charset: String? = null,
  crossinline block: META.() -> Unit = {},
): HTMLMetaElement = META(attributesMapOf("name", name,"content", content,"charset", charset), this)
    .visitAndFinalize(this, block)  as HTMLMetaElement

/**
 * Gauge
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.meter(classes: String? = null, crossinline
    block: METER.() -> Unit = {}): HTMLMeterElement = METER(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLMeterElement

/**
 * Section with navigational links
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.nav(classes: String? = null, crossinline
    block: NAV.() -> Unit = {}): Element = NAV(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Generic metainformation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.noScript(classes: String? = null, crossinline
    block: NOSCRIPT.() -> Unit = {}): Element = NOSCRIPT(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Generic embedded object
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.htmlObject(classes: String? = null, crossinline
    block: OBJECT.() -> Unit = {}): Element = OBJECT(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Ordered list
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.ol(classes: String? = null, crossinline block: OL.() -> Unit
    = {}): Element = OL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Option group
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.optGroup(
  label: String? = null,
  classes: String? = null,
  crossinline block: OPTGROUP.() -> Unit = {},
): HTMLOptGroupElement = OPTGROUP(attributesMapOf("label", label,"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLOptGroupElement

/**
 * Selectable choice
 */
@HtmlTagMarker
public fun TagConsumer<Element>.option(classes: String? = null, content: String = ""):
    HTMLOptionElement = OPTION(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})  as HTMLOptionElement

/**
 * Selectable choice
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.option(classes: String? = null, crossinline
    block: OPTION.() -> Unit = {}): HTMLOptionElement = OPTION(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLOptionElement

/**
 * Calculated output value
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.output(classes: String? = null, crossinline
    block: OUTPUT.() -> Unit = {}): HTMLOutputElement = OUTPUT(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLOutputElement

/**
 * Paragraph
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.p(classes: String? = null, crossinline block: P.() -> Unit =
    {}): HTMLParagraphElement = P(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLParagraphElement

/**
 * Named property value
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.`param`(
  name: String? = null,
  `value`: String? = null,
  crossinline block: PARAM.() -> Unit = {},
): HTMLParamElement = PARAM(attributesMapOf("name", name,"value", value), this)
    .visitAndFinalize(this, block)  as HTMLParamElement

/**
 * Pictures container
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.picture(crossinline block: PICTURE.() -> Unit = {}):
    HTMLPictureElement = PICTURE(emptyMap, this)
    .visitAndFinalize(this, block)  as HTMLPictureElement

/**
 * Preformatted text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.pre(classes: String? = null, crossinline
    block: PRE.() -> Unit = {}): HTMLPreElement = PRE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLPreElement

/**
 * Progress bar
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.progress(classes: String? = null, crossinline
    block: PROGRESS.() -> Unit = {}): HTMLProgressElement = PROGRESS(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLProgressElement

/**
 * Short inline quotation
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.q(classes: String? = null, crossinline block: Q.() -> Unit =
    {}): Element = Q(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Parenthesis for ruby annotation text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.rp(classes: String? = null, crossinline block: RP.() -> Unit
    = {}): Element = RP(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Ruby annotation text
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.rt(classes: String? = null, crossinline block: RT.() -> Unit
    = {}): Element = RT(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Ruby annotation(s)
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.ruby(classes: String? = null, crossinline
    block: RUBY.() -> Unit = {}): Element = RUBY(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Strike-through text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.s(classes: String? = null, crossinline block: S.() -> Unit =
    {}): Element = S(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Sample or quote text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.samp(classes: String? = null, crossinline
    block: SAMP.() -> Unit = {}): Element = SAMP(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Script statements
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun TagConsumer<Element>.script(
  type: String? = null,
  src: String? = null,
  crossorigin: ScriptCrossorigin? = null,
  content: String = "",
): HTMLScriptElement = SCRIPT(attributesMapOf("type", type,"src", src,"crossorigin",
    crossorigin?.enumEncode()), this)
    .visitAndFinalize(this, {+content})  as HTMLScriptElement

/**
 * Script statements
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.script(
  type: String? = null,
  src: String? = null,
  crossorigin: ScriptCrossorigin? = null,
  crossinline block: SCRIPT.() -> Unit = {},
): HTMLScriptElement = SCRIPT(attributesMapOf("type", type,"src", src,"crossorigin",
    crossorigin?.enumEncode()), this)
    .visitAndFinalize(this, block)  as HTMLScriptElement

/**
 * Generic document or application section
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.section(classes: String? = null, crossinline
    block: SECTION.() -> Unit = {}): Element = SECTION(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Option selector
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.select(classes: String? = null, crossinline
    block: SELECT.() -> Unit = {}): HTMLSelectElement = SELECT(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLSelectElement

/**
 * Small text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.small(classes: String? = null, crossinline
    block: SMALL.() -> Unit = {}): Element = SMALL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Media source for 
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.source(classes: String? = null, crossinline
    block: SOURCE.() -> Unit = {}): HTMLSourceElement = SOURCE(attributesMapOf("class", classes),
    this)
    .visitAndFinalize(this, block)  as HTMLSourceElement

/**
 * Generic language/style container
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.span(classes: String? = null, crossinline
    block: SPAN.() -> Unit = {}): HTMLSpanElement = SPAN(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLSpanElement

/**
 * Strong emphasis
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.strong(classes: String? = null, crossinline
    block: STRONG.() -> Unit = {}): Element = STRONG(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Style info
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun TagConsumer<Element>.style(type: String? = null, content: String = ""): HTMLStyleElement
    = STYLE(attributesMapOf("type", type), this)
    .visitAndFinalize(this, {+content})  as HTMLStyleElement

/**
 * Style info
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.style(type: String? = null, crossinline
    block: STYLE.() -> Unit = {}): HTMLStyleElement = STYLE(attributesMapOf("type", type), this)
    .visitAndFinalize(this, block)  as HTMLStyleElement

/**
 * Subscript
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.sub(classes: String? = null, crossinline
    block: SUB.() -> Unit = {}): Element = SUB(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Caption for 
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.summary(classes: String? = null, crossinline
    block: SUMMARY.() -> Unit = {}): Element = SUMMARY(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Superscript
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.sup(classes: String? = null, crossinline
    block: SUP.() -> Unit = {}): Element = SUP(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

@HtmlTagMarker
public fun TagConsumer<Element>.svg(classes: String? = null, content: String = ""): Element =
    SVG(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content}) 

@HtmlTagMarker
public inline fun TagConsumer<Element>.svg(classes: String? = null, crossinline
    block: SVG.() -> Unit = {}): Element = SVG(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 *
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.table(classes: String? = null, crossinline
    block: TABLE.() -> Unit = {}): HTMLTableElement = TABLE(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTableElement

/**
 * Table body
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.tbody(classes: String? = null, crossinline
    block: TBODY.() -> Unit = {}): HTMLTableSectionElement = TBODY(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLTableSectionElement

/**
 * Table data cell
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.td(classes: String? = null, crossinline block: TD.() -> Unit
    = {}): HTMLTableCellElement = TD(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTableCellElement

/**
 * Multi-line text field
 */
@HtmlTagMarker
public fun TagConsumer<Element>.textArea(
  rows: String? = null,
  cols: String? = null,
  wrap: TextAreaWrap? = null,
  classes: String? = null,
  content: String = "",
): HTMLTextAreaElement = TEXTAREA(attributesMapOf("rows", rows,"cols", cols,"wrap",
    wrap?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, {+content})  as HTMLTextAreaElement

/**
 * Multi-line text field
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.textArea(
  rows: String? = null,
  cols: String? = null,
  wrap: TextAreaWrap? = null,
  classes: String? = null,
  crossinline block: TEXTAREA.() -> Unit = {},
): HTMLTextAreaElement = TEXTAREA(attributesMapOf("rows", rows,"cols", cols,"wrap",
    wrap?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTextAreaElement

/**
 * Table footer
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.tfoot(classes: String? = null, crossinline
    block: TFOOT.() -> Unit = {}): HTMLTableSectionElement = TFOOT(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLTableSectionElement

/**
 * Table header cell
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.th(
  scope: ThScope? = null,
  classes: String? = null,
  crossinline block: TH.() -> Unit = {},
): HTMLTableCellElement = TH(attributesMapOf("scope", scope?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTableCellElement

/**
 * Table header
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.thead(classes: String? = null, crossinline
    block: THEAD.() -> Unit = {}): HTMLTableSectionElement = THEAD(attributesMapOf("class",
    classes), this)
    .visitAndFinalize(this, block)  as HTMLTableSectionElement

/**
 * Machine-readable equivalent of date- or time-related data
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.time(classes: String? = null, crossinline
    block: TIME.() -> Unit = {}): HTMLTimeElement = TIME(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTimeElement

/**
 * Document title
 */
@HtmlTagMarker
public fun TagConsumer<Element>.title(content: String = ""): HTMLTitleElement = TITLE(emptyMap,
    this)
    .visitAndFinalize(this, {+content})  as HTMLTitleElement

/**
 * Document title
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.title(crossinline block: TITLE.() -> Unit = {}):
    HTMLTitleElement = TITLE(emptyMap, this)
    .visitAndFinalize(this, block)  as HTMLTitleElement

/**
 * Table row
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.tr(classes: String? = null, crossinline block: TR.() -> Unit
    = {}): HTMLTableRowElement = TR(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLTableRowElement

/**
 * Underlined text style
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.u(classes: String? = null, crossinline block: U.() -> Unit =
    {}): Element = U(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Unordered list
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.ul(classes: String? = null, crossinline block: UL.() -> Unit
    = {}): Element = UL(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Unordered list
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.htmlVar(classes: String? = null, crossinline
    block: VAR.() -> Unit = {}): Element = VAR(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block) 

/**
 * Video player
 */
@HtmlTagMarker
public inline fun TagConsumer<Element>.video(classes: String? = null, crossinline
    block: VIDEO.() -> Unit = {}): HTMLVideoElement = VIDEO(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, block)  as HTMLVideoElement
