/*******************************************************************************
    DO NOT EDIT
    This file was generated by module generate
*******************************************************************************/
package kotlinx.html

import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.InvocationKind
import kotlin.contracts.contract
import kotlinx.html.*
import kotlinx.html.attributes.*

import kotlin.Deprecated
import kotlin.String
import kotlin.Suppress
import kotlin.Unit
import kotlinx.html.A
import kotlinx.html.ABBR
import kotlinx.html.ADDRESS
import kotlinx.html.AREA
import kotlinx.html.ARTICLE
import kotlinx.html.AReferrerPolicy
import kotlinx.html.ASIDE
import kotlinx.html.AUDIO
import kotlinx.html.AreaShape
import kotlinx.html.B
import kotlinx.html.BASE
import kotlinx.html.BDI
import kotlinx.html.BDO
import kotlinx.html.BLOCKQUOTE
import kotlinx.html.BODY
import kotlinx.html.BR
import kotlinx.html.BUTTON
import kotlinx.html.ButtonFormEncType
import kotlinx.html.ButtonFormMethod
import kotlinx.html.ButtonType
import kotlinx.html.CANVAS
import kotlinx.html.CAPTION
import kotlinx.html.CITE
import kotlinx.html.CODE
import kotlinx.html.COL
import kotlinx.html.COLGROUP
import kotlinx.html.COMMAND
import kotlinx.html.CommandType
import kotlinx.html.DATALIST
import kotlinx.html.DD
import kotlinx.html.DEL
import kotlinx.html.DETAILS
import kotlinx.html.DFN
import kotlinx.html.DIALOG
import kotlinx.html.DIV
import kotlinx.html.DL
import kotlinx.html.DT
import kotlinx.html.EM
import kotlinx.html.EMBED
import kotlinx.html.FIELDSET
import kotlinx.html.FIGCAPTION
import kotlinx.html.FIGURE
import kotlinx.html.FOOTER
import kotlinx.html.FORM
import kotlinx.html.FormEncType
import kotlinx.html.FormMethod
import kotlinx.html.H1
import kotlinx.html.H2
import kotlinx.html.H3
import kotlinx.html.H4
import kotlinx.html.H5
import kotlinx.html.H6
import kotlinx.html.HEAD
import kotlinx.html.HEADER
import kotlinx.html.HGROUP
import kotlinx.html.HR
import kotlinx.html.HTML
import kotlinx.html.HtmlTagMarker
import kotlinx.html.I
import kotlinx.html.IFRAME
import kotlinx.html.IMG
import kotlinx.html.INPUT
import kotlinx.html.INS
import kotlinx.html.IframeSandbox
import kotlinx.html.ImgLoading
import kotlinx.html.InputFormEncType
import kotlinx.html.InputFormMethod
import kotlinx.html.InputType
import kotlinx.html.KBD
import kotlinx.html.KEYGEN
import kotlinx.html.KeyGenKeyType
import kotlinx.html.LABEL
import kotlinx.html.LEGEND
import kotlinx.html.LI
import kotlinx.html.LINK
import kotlinx.html.LinkAs
import kotlinx.html.MAIN
import kotlinx.html.MAP
import kotlinx.html.MARK
import kotlinx.html.MATH
import kotlinx.html.MATHML
import kotlinx.html.META
import kotlinx.html.METER
import kotlinx.html.NAV
import kotlinx.html.NOSCRIPT
import kotlinx.html.OBJECT
import kotlinx.html.OL
import kotlinx.html.OPTGROUP
import kotlinx.html.OPTION
import kotlinx.html.OUTPUT
import kotlinx.html.P
import kotlinx.html.PARAM
import kotlinx.html.PICTURE
import kotlinx.html.PRE
import kotlinx.html.PROGRESS
import kotlinx.html.Q
import kotlinx.html.RP
import kotlinx.html.RT
import kotlinx.html.RUBY
import kotlinx.html.S
import kotlinx.html.SAMP
import kotlinx.html.SCRIPT
import kotlinx.html.SECTION
import kotlinx.html.SELECT
import kotlinx.html.SLOT
import kotlinx.html.SMALL
import kotlinx.html.SOURCE
import kotlinx.html.SPAN
import kotlinx.html.STRONG
import kotlinx.html.STYLE
import kotlinx.html.SUB
import kotlinx.html.SUMMARY
import kotlinx.html.SUP
import kotlinx.html.SVG
import kotlinx.html.ScriptCrossorigin
import kotlinx.html.TABLE
import kotlinx.html.TBODY
import kotlinx.html.TD
import kotlinx.html.TEMPLATE
import kotlinx.html.TEXTAREA
import kotlinx.html.TFOOT
import kotlinx.html.TH
import kotlinx.html.THEAD
import kotlinx.html.TIME
import kotlinx.html.TITLE
import kotlinx.html.TR
import kotlinx.html.TagConsumer
import kotlinx.html.TextAreaWrap
import kotlinx.html.ThScope
import kotlinx.html.U
import kotlinx.html.UL
import kotlinx.html.VAR
import kotlinx.html.VIDEO

/**
 * Anchor
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.a(
  href: String? = null,
  target: String? = null,
  referrerPolicy: AReferrerPolicy? = null,
  classes: String? = null,
  crossinline block: A.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return A(attributesMapOf("href", href,"target", target,"referrerpolicy",
      referrerPolicy?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Abbreviated form (e.g., WWW, HTTP,etc.)
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.abbr(classes: String? = null, crossinline
    block: ABBR.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return ABBR(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Information on author
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.address(classes: String? = null, crossinline
    block: ADDRESS.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return ADDRESS(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Client-side image map area
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.area(
  shape: AreaShape? = null,
  alt: String? = null,
  classes: String? = null,
  crossinline block: AREA.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return AREA(attributesMapOf("shape", shape?.enumEncode(),"alt", alt,"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Self-contained syndicatable or reusable composition
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.article(classes: String? = null, crossinline
    block: ARTICLE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return ARTICLE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Sidebar for tangentially related content
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.aside(classes: String? = null, crossinline
    block: ASIDE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return ASIDE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Audio player
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.audio(classes: String? = null, crossinline
    block: AUDIO.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return AUDIO(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Bold text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.b(classes: String? = null, crossinline
    block: B.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return B(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Document base URI
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.base(classes: String? = null, crossinline
    block: BASE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BASE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Text directionality isolation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.bdi(classes: String? = null, crossinline
    block: BDI.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BDI(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * I18N BiDi over-ride
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.bdo(classes: String? = null, crossinline
    block: BDO.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BDO(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Long quotation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.blockQuote(classes: String? = null, crossinline
    block: BLOCKQUOTE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BLOCKQUOTE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Document body
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.body(classes: String? = null, crossinline
    block: BODY.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BODY(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Forced line break
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.br(classes: String? = null, crossinline
    block: BR.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BR(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Push button
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.button(
  formEncType: ButtonFormEncType? = null,
  formMethod: ButtonFormMethod? = null,
  name: String? = null,
  type: ButtonType? = null,
  classes: String? = null,
  crossinline block: BUTTON.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return BUTTON(attributesMapOf("formenctype", formEncType?.enumEncode(),"formmethod",
      formMethod?.enumEncode(),"name", name,"type", type?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Scriptable bitmap canvas
 */
@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.canvas(classes: String? = null, content: String = ""): T =
    CANVAS(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})

/**
 * Scriptable bitmap canvas
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.canvas(classes: String? = null, crossinline
    block: CANVAS.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return CANVAS(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table caption
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.caption(classes: String? = null, crossinline
    block: CAPTION.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return CAPTION(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Citation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.cite(classes: String? = null, crossinline
    block: CITE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return CITE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Computer code fragment
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.code(classes: String? = null, crossinline
    block: CODE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return CODE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table column
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.col(classes: String? = null, crossinline
    block: COL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return COL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table column group
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.colGroup(classes: String? = null, crossinline
    block: COLGROUP.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return COLGROUP(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.command(
  type: CommandType? = null,
  classes: String? = null,
  crossinline block: COMMAND.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return COMMAND(attributesMapOf("type", type?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Container for options for 
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dataList(classes: String? = null, crossinline
    block: DATALIST.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DATALIST(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Definition description
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dd(classes: String? = null, crossinline
    block: DD.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DD(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Deleted text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.del(classes: String? = null, crossinline
    block: DEL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DEL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Disclosure control for hiding details
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.details(classes: String? = null, crossinline
    block: DETAILS.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DETAILS(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Instance definition
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dfn(classes: String? = null, crossinline
    block: DFN.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DFN(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Dialog box or window
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dialog(classes: String? = null, crossinline
    block: DIALOG.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DIALOG(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Generic language/style container
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.div(classes: String? = null, crossinline
    block: DIV.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DIV(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Definition list
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dl(classes: String? = null, crossinline
    block: DL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Definition term
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.dt(classes: String? = null, crossinline
    block: DT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return DT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Emphasis
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.em(classes: String? = null, crossinline
    block: EM.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return EM(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Plugin
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.embed(classes: String? = null, crossinline
    block: EMBED.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return EMBED(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Form control group
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.fieldSet(classes: String? = null, crossinline
    block: FIELDSET.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return FIELDSET(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Caption for 
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.figcaption(classes: String? = null, crossinline
    block: FIGCAPTION.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return FIGCAPTION(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Figure with optional caption
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.figure(classes: String? = null, crossinline
    block: FIGURE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return FIGURE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Footer for a page or section
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.footer(classes: String? = null, crossinline
    block: FOOTER.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return FOOTER(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Interactive form
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.form(
  action: String? = null,
  encType: FormEncType? = null,
  method: FormMethod? = null,
  classes: String? = null,
  crossinline block: FORM.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return FORM(attributesMapOf("action", action,"enctype", encType?.enumEncode(),"method",
      method?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h1(classes: String? = null, crossinline
    block: H1.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H1(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h2(classes: String? = null, crossinline
    block: H2.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H2(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h3(classes: String? = null, crossinline
    block: H3.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H3(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h4(classes: String? = null, crossinline
    block: H4.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H4(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h5(classes: String? = null, crossinline
    block: H5.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H5(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Heading
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.h6(classes: String? = null, crossinline
    block: H6.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return H6(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Document head
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun <T, C : TagConsumer<T>> C.head(content: String = ""): T = HEAD(emptyMap, this)
    .visitAndFinalize(this, {+content})

/**
 * Document head
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.head(crossinline block: HEAD.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return HEAD(emptyMap, this)
      .visitAndFinalize(this, block)
}

/**
 * Introductory or navigational aids for a page or section
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.`header`(classes: String? = null, crossinline
    block: HEADER.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return HEADER(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.hGroup(classes: String? = null, crossinline
    block: HGROUP.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return HGROUP(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Horizontal rule
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.hr(classes: String? = null, crossinline
    block: HR.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return HR(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Document root element
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun <T, C : TagConsumer<T>> C.html(content: String = "", namespace: String? = null): T =
    HTML(emptyMap, this, namespace)
    .visitAndFinalize(this, {+content})

/**
 * Document root element
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.html(namespace: String? = null, crossinline
    block: HTML.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return HTML(emptyMap, this, namespace)
      .visitAndFinalize(this, block)
}

/**
 * Italic text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.i(classes: String? = null, crossinline
    block: I.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return I(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Inline subwindow
 */
@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.iframe(
  sandbox: IframeSandbox? = null,
  classes: String? = null,
  content: String = "",
): T = IFRAME(attributesMapOf("sandbox", sandbox?.enumEncode(),"class", classes), this)
    .visitAndFinalize(this, {+content})

/**
 * Inline subwindow
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.iframe(
  sandbox: IframeSandbox? = null,
  classes: String? = null,
  crossinline block: IFRAME.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return IFRAME(attributesMapOf("sandbox", sandbox?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Embedded image
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.img(
  alt: String? = null,
  src: String? = null,
  loading: ImgLoading? = null,
  classes: String? = null,
  crossinline block: IMG.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return IMG(attributesMapOf("alt", alt,"src", src,"loading", loading?.enumEncode(),"class",
      classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Form control
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.input(
  type: InputType? = null,
  formEncType: InputFormEncType? = null,
  formMethod: InputFormMethod? = null,
  name: String? = null,
  classes: String? = null,
  crossinline block: INPUT.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return INPUT(attributesMapOf("type", type?.enumEncode(),"formenctype",
      formEncType?.enumEncode(),"formmethod", formMethod?.enumEncode(),"name", name,"class",
      classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Inserted text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.ins(classes: String? = null, crossinline
    block: INS.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return INS(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Text to be entered by the user
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.kbd(classes: String? = null, crossinline
    block: KBD.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return KBD(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Cryptographic key-pair generator form control
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.keyGen(
  keyType: KeyGenKeyType? = null,
  classes: String? = null,
  crossinline block: KEYGEN.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return KEYGEN(attributesMapOf("keytype", keyType?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Form field label text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.label(classes: String? = null, crossinline
    block: LABEL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return LABEL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Fieldset legend
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.legend(classes: String? = null, crossinline
    block: LEGEND.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return LEGEND(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * List item
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.li(classes: String? = null, crossinline
    block: LI.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return LI(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * A media-independent link
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.link(
  href: String? = null,
  rel: String? = null,
  type: String? = null,
  htmlAs: LinkAs? = null,
  crossinline block: LINK.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return LINK(attributesMapOf("href", href,"rel", rel,"type", type,"as", htmlAs?.enumEncode()),
      this)
      .visitAndFinalize(this, block)
}

/**
 * Container for the dominant contents of another element
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.main(classes: String? = null, crossinline
    block: MAIN.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return MAIN(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Client-side image map
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.map(
  name: String? = null,
  classes: String? = null,
  crossinline block: MAP.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return MAP(attributesMapOf("name", name,"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Highlight
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.mark(classes: String? = null, crossinline
    block: MARK.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return MARK(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.math(classes: String? = null, crossinline
    block: MATH.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return MATH(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.mathml(classes: String? = null, content: String = ""): T =
    MATHML(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.mathml(classes: String? = null, crossinline
    block: MATHML.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return MATHML(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Generic metainformation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.meta(
  name: String? = null,
  content: String? = null,
  charset: String? = null,
  crossinline block: META.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return META(attributesMapOf("name", name,"content", content,"charset", charset), this)
      .visitAndFinalize(this, block)
}

/**
 * Gauge
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.meter(classes: String? = null, crossinline
    block: METER.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return METER(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Section with navigational links
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.nav(classes: String? = null, crossinline
    block: NAV.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return NAV(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Generic metainformation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.noScript(classes: String? = null, crossinline
    block: NOSCRIPT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return NOSCRIPT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Generic embedded object
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.htmlObject(classes: String? = null, crossinline
    block: OBJECT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return OBJECT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Ordered list
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.ol(classes: String? = null, crossinline
    block: OL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return OL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Option group
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.optGroup(
  label: String? = null,
  classes: String? = null,
  crossinline block: OPTGROUP.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return OPTGROUP(attributesMapOf("label", label,"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Selectable choice
 */
@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.option(classes: String? = null, content: String = ""): T =
    OPTION(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})

/**
 * Selectable choice
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.option(classes: String? = null, crossinline
    block: OPTION.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return OPTION(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Calculated output value
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.output(classes: String? = null, crossinline
    block: OUTPUT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return OUTPUT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Paragraph
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.p(classes: String? = null, crossinline
    block: P.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return P(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Named property value
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.`param`(
  name: String? = null,
  `value`: String? = null,
  crossinline block: PARAM.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return PARAM(attributesMapOf("name", name,"value", value), this)
      .visitAndFinalize(this, block)
}

/**
 * Pictures container
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.picture(crossinline block: PICTURE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return PICTURE(emptyMap, this)
      .visitAndFinalize(this, block)
}

/**
 * Preformatted text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.pre(classes: String? = null, crossinline
    block: PRE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return PRE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Progress bar
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.progress(classes: String? = null, crossinline
    block: PROGRESS.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return PROGRESS(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Short inline quotation
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.q(classes: String? = null, crossinline
    block: Q.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return Q(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Parenthesis for ruby annotation text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.rp(classes: String? = null, crossinline
    block: RP.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return RP(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Ruby annotation text
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.rt(classes: String? = null, crossinline
    block: RT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return RT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Ruby annotation(s)
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.ruby(classes: String? = null, crossinline
    block: RUBY.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return RUBY(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Strike-through text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.s(classes: String? = null, crossinline
    block: S.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return S(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Sample or quote text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.samp(classes: String? = null, crossinline
    block: SAMP.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SAMP(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Script statements
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun <T, C : TagConsumer<T>> C.script(
  type: String? = null,
  src: String? = null,
  crossorigin: ScriptCrossorigin? = null,
  content: String = "",
): T = SCRIPT(attributesMapOf("type", type,"src", src,"crossorigin", crossorigin?.enumEncode()),
    this)
    .visitAndFinalize(this, {+content})

/**
 * Script statements
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.script(
  type: String? = null,
  src: String? = null,
  crossorigin: ScriptCrossorigin? = null,
  crossinline block: SCRIPT.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SCRIPT(attributesMapOf("type", type,"src", src,"crossorigin", crossorigin?.enumEncode()),
      this)
      .visitAndFinalize(this, block)
}

/**
 * Generic document or application section
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.section(classes: String? = null, crossinline
    block: SECTION.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SECTION(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Option selector
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.select(classes: String? = null, crossinline
    block: SELECT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SELECT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.slot(classes: String? = null, crossinline
    block: SLOT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SLOT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Small text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.small(classes: String? = null, crossinline
    block: SMALL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SMALL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Media source for 
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.source(classes: String? = null, crossinline
    block: SOURCE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SOURCE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Generic language/style container
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.span(classes: String? = null, crossinline
    block: SPAN.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SPAN(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Strong emphasis
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.strong(classes: String? = null, crossinline
    block: STRONG.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return STRONG(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Style info
 */
@HtmlTagMarker
@Suppress("DEPRECATION")
@Deprecated("This tag doesn't support content or requires unsafe (try unsafe {})")
public fun <T, C : TagConsumer<T>> C.style(type: String? = null, content: String = ""): T =
    STYLE(attributesMapOf("type", type), this)
    .visitAndFinalize(this, {+content})

/**
 * Style info
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.style(type: String? = null, crossinline
    block: STYLE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return STYLE(attributesMapOf("type", type), this)
      .visitAndFinalize(this, block)
}

/**
 * Subscript
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.sub(classes: String? = null, crossinline
    block: SUB.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SUB(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Caption for 
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.summary(classes: String? = null, crossinline
    block: SUMMARY.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SUMMARY(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Superscript
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.sup(classes: String? = null, crossinline
    block: SUP.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SUP(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.svg(classes: String? = null, content: String = ""): T =
    SVG(attributesMapOf("class", classes), this)
    .visitAndFinalize(this, {+content})

@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.svg(classes: String? = null, crossinline
    block: SVG.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return SVG(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 *
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.table(classes: String? = null, crossinline
    block: TABLE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TABLE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table body
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.tbody(classes: String? = null, crossinline
    block: TBODY.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TBODY(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table data cell
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.td(classes: String? = null, crossinline
    block: TD.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TD(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Template
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.template(classes: String? = null, crossinline
    block: TEMPLATE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TEMPLATE(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Multi-line text field
 */
@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.textArea(
  rows: String? = null,
  cols: String? = null,
  wrap: TextAreaWrap? = null,
  classes: String? = null,
  content: String = "",
): T = TEXTAREA(attributesMapOf("rows", rows,"cols", cols,"wrap", wrap?.enumEncode(),"class",
    classes), this)
    .visitAndFinalize(this, {+content})

/**
 * Multi-line text field
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.textArea(
  rows: String? = null,
  cols: String? = null,
  wrap: TextAreaWrap? = null,
  classes: String? = null,
  crossinline block: TEXTAREA.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TEXTAREA(attributesMapOf("rows", rows,"cols", cols,"wrap", wrap?.enumEncode(),"class",
      classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table footer
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.tfoot(classes: String? = null, crossinline
    block: TFOOT.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TFOOT(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table header cell
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.th(
  scope: ThScope? = null,
  classes: String? = null,
  crossinline block: TH.() -> Unit = {},
): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TH(attributesMapOf("scope", scope?.enumEncode(),"class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Table header
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.thead(classes: String? = null, crossinline
    block: THEAD.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return THEAD(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Machine-readable equivalent of date- or time-related data
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.time(classes: String? = null, crossinline
    block: TIME.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TIME(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Document title
 */
@HtmlTagMarker
public fun <T, C : TagConsumer<T>> C.title(content: String = ""): T = TITLE(emptyMap, this)
    .visitAndFinalize(this, {+content})

/**
 * Document title
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.title(crossinline block: TITLE.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TITLE(emptyMap, this)
      .visitAndFinalize(this, block)
}

/**
 * Table row
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.tr(classes: String? = null, crossinline
    block: TR.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return TR(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Underlined text style
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.u(classes: String? = null, crossinline
    block: U.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return U(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Unordered list
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.ul(classes: String? = null, crossinline
    block: UL.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return UL(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Unordered list
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.htmlVar(classes: String? = null, crossinline
    block: VAR.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return VAR(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}

/**
 * Video player
 */
@HtmlTagMarker
@OptIn(ExperimentalContracts::class)
public inline fun <T, C : TagConsumer<T>> C.video(classes: String? = null, crossinline
    block: VIDEO.() -> Unit = {}): T {
  contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }
  return VIDEO(attributesMapOf("class", classes), this)
      .visitAndFinalize(this, block)
}
